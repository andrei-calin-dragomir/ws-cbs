from flask import Flask, request, jsonify, redirect
import re
import string
import random
import threading
import time
from datetime import datetime

app = Flask(__name__)

#############################################################
#               DATA STORAGE & CONFIGURATION
#############################################################

# Memory storage for URL mappings
url_store = {}

# Regular expression for validating proper URL formats (only URLs starting with http or https)
URL_REGEX = re.compile(r'^(http|https)://[^ "<>]*$')

# Base62 characters
BASE62 = string.ascii_letters + string.digits
custom_ids = set()  # Track used custom IDs

#############################################################
#              HOW IS THE URL BEING SHORTENED?
#############################################################

# How the URL Shortening Process is Working:

# 1. User submits a long URL via a POST request (along with optional expiry time and custom short ID)
# 2. If a custom short ID is provided, we check if its available and store the URL under that ID
# 3. If no custom ID is provided, we generate a random 6 character short ID using Base62 encoding
# 4. We check for uniqueness by making sure the generated ID is not in use already
# 5. The mapping (short ID to original URL) is stored in a memory dictionary
# 6. The user gets the shortened URL as a response

# Later, when the user accesses the short link:
# 1. A GET request fetches the original URL using the short ID
# 2. If the link has expired, it is deleted and error is returned
# 3. If the link is valid, the user is redirected to the original URL

#############################################################
#                GENERATE RANDOM SHORT ID
#############################################################

def generate_short_id(length=6):
#############################################################
#    Generates a random Base62 short ID with the specified length
#    Base62 encoding uses: 26 lowercase letters (a-z) + 26 uppercase letters (A-Z) + 10 digits (0-9)
#    This provides a total of 62 possible characters

#    Example:
#    Random 6-character ID could be "A1b2C3"
#    With 62^6 possible combinations (~56 billion) chances of repetition are very low
#############################################################
    return ''.join(random.choices(BASE62, k=length))

#############################################################
#              CREATE SHORT URL (POST METHOD)
#############################################################
@app.route("/", methods=["POST"])
def shorten_url():
#############################################################
#       Creates a short URL with an optional custom short ID and expiry time.
#       Request JSON format:
#        {
#            "url": "original URL",
#            "custom_id": "custom short id",  # Optional (Extra: User can define a custom short ID that can be assigned instead of the random one generated by BASE62 encoding)
#            "expiry_time": "YYYY-MM-DD HH:MM:SS"  # Optional (Extra: User can set an expiry time for the shortened URL. It does not have an expiry time by default or if not set)
#        }
#############################################################
    data = request.json
    long_url = data.get("url")
    custom_id = data.get("custom_id")  # Optional custom short ID defined by user
    expiry_time = data.get("expiry_time")  # Optional expiry timestamp

    if not long_url:
        return jsonify({"error": "URL is required"}), 400

        # Convert entered date and time to UNIX timestamp
    if expiry_time:
        try:
            expiry_time = float(datetime.strptime(expiry_time, "%Y-%m-%d %H:%M:%S").timestamp())
        except ValueError:
            return jsonify({"error": "Invalid date format. Use 'YYYY-MM-DD HH:MM:SS'"}), 400

    # If the user provides a custom ID
    if custom_id:
        if custom_id in url_store:  # Check if the ID is already taken
            return jsonify({"error": "Custom ID already taken"}), 409
        short_id = custom_id
    else:
        # Otherwise generate a random Base62 ID
        short_id = generate_short_id()
        while short_id in url_store:  # Makes sure ID is unique
            short_id = generate_short_id()

    # Store with expiry timestamp
    url_store[short_id] = (long_url, expiry_time)
    return jsonify({"short_id": short_id}), 201

#############################################################
#              RETRIEVE ORIGINAL URL (GET METHOD)
#############################################################

@app.route("/<string:short_id>", methods=["GET"])
def get_url(short_id):
#############################################################
#    Retrieves the original URL from the shortened URL
#    If the URL has expired, it deletes the entry and returns an error
#############################################################
    if short_id not in url_store:
        return jsonify({"error": "Short URL not found"}), 404

    long_url, expiry_time = url_store[short_id]

    # Check if the URL has expired
    if expiry_time and isinstance(expiry_time, (int, float)) and time.time() > float(expiry_time):
        del url_store[short_id]  # Remove expired URL
        return jsonify({"error": "This short URL has expired"}), 410

    return jsonify({"original_url": long_url}), 200

#############################################################
#   UPDATE SHORT URL OR EXPIRY DATE AND TIME (PUT METHOD)
#############################################################

@app.route("/<string:short_id>", methods=["PUT"])
def update_url(short_id):
#############################################################
#    Updates a shortened URL or expiry time or change the short URL
#    Request JSON format:
#    {
#        "url": "new url",  # Optional
#        "expiry_time": "YYYY-MM-DD HH:MM:SS",  # Optional
#        "new_custom_id": "new short url"  # Optional
#    }
#############################################################
    if short_id not in url_store:
        return jsonify({"error": "Short URL not found"}), 404

    data = request.json
    new_url = data.get("url")
    new_expiry = data.get("expiry_time")
    new_custom_id = data.get("new_custom_id")  # Optional new short ID

    old_url, old_expiry = url_store[short_id]  # Get current existing values

    # Validate and update expiry time
    if new_expiry:
        try:
            new_expiry = float(datetime.strptime(new_expiry, "%Y-%m-%d %H:%M:%S").timestamp())
        except ValueError:
            return jsonify({"error": "Invalid date format. Use 'YYYY-MM-DD HH:MM:SS'"}), 400
    else:
        new_expiry = old_expiry  # Keep existing expiry

    # Validate and update URL
    if new_url:
        if not URL_REGEX.match(new_url):
            return jsonify({"error": "Invalid URL format"}), 400
    else:
        new_url = old_url  # Keep existing URL

    # IF short url change is needed
    if new_custom_id:
        if new_custom_id in url_store:
            return jsonify({"error": "New Custom ID already taken"}), 409
        # Move the URL mapping to the new custom url
        del url_store[short_id]
        url_store[new_custom_id] = (new_url, new_expiry)
        return jsonify({
            "message": "Updated successfully",
            "new_short_id": new_custom_id,
            "expires_at": new_expiry
        }), 200

    # Update only URL and expiry if no custom ID change
    url_store[short_id] = (new_url, new_expiry)
    return jsonify({
        "message": "Updated successfully",
        "short_id": short_id,
        "expires_at": new_expiry
    }), 200

#############################################################
#             DELETE SHORT URL (DELETE METHOD)
#############################################################

@app.route("/<string:short_id>", methods=["DELETE"])
def delete_url(short_id):
    # Deleting a shortened URL manually
    if short_id in url_store:
        del url_store[short_id]
        return '', 204 # No content
    return jsonify({"error": "Short URL not found"}), 404

#############################################################
#            LIST ALL SHORTENED URLs (GET METHOD)
#############################################################

@app.route("/", methods=["GET"])
def list_shortened_urls():
    return jsonify(list(url_store.keys())), 200 # Lists all shortened URLs stored currently

#############################################################
#     AUTO CLEAN EXPIRED LINKS (RUNS IN THE BACKGROUND)
#############################################################

def cleanup_expired_links():
    # Runs in a separate thread to delete expired URLs every 10 mins
    while True:
        time.sleep(600)  # Runs every 600 secs
        expired_keys = [key for key, (_, expiry) in url_store.items() if expiry and time.time() > expiry]
        for key in expired_keys:
            del url_store[key]
        if expired_keys:
            print(f" Cleaned up {len(expired_keys)} expired links.")

# Start auto cleanup thread
cleanup_thread = threading.Thread(target=cleanup_expired_links, daemon=True)
cleanup_thread.start()


if __name__ == "__main__":
    app.run(debug=True)

